/*                                 REXX                             */
/********************************************************************/
/*                                                                  */
/*         $$$$  SSSS Y   Y  SSSS  III  N   N FFFFF  OOO            */
/*        $ $   S      Y Y  S       I   NN  N F     O   O           */
/*         $$$   SSS    Y    SSS    I   N N N FFFF  O   O           */
/*          $ $     S   Y       S   I   N  NN F     O   O           */
/*        $$$$  SSSS    Y   SSSS   III  N   N F      OOO            */
/*                                                                  */
/********************************************************************/
/*   Display System Information using ISPF panel.                   */
/*------------------------------------------------------------------*/
/*                                                                  */
/*   Changes:                                                       */
/*      02/16/17 - V1.00 - VNV - Added the first time.              */
/*      07/12/17 - V2.00 - VNV - Added the DVOL (Bernie's version)  */
/*                         to collect the Res volumes (M1-6) for    */
/*                         display.                                 */
/*      07/13/17 - V2.01 - VNV - Change to not display MAxxxx-MZxxxx*/
/*                         vols (they were sorted and become the 1st*/
/*                         volumes in the list).                    */
/*      08/15/17 - V2.02 - VNV - Add call to IWMQVS to get the      */
/*                         dynamic upgraded model number            */
/*      08/22/17 - V2.03 - VNV - Add the Help screen (tutorial).    */
/*      05/17/18 - V2.04 - VNV - Change to fix the Scroll amount.   */
/*                         It never did work before.                */
/*      08/08/18 - V2.05 - VNV - Change to swap display positions   */
/*                         of Sysplex/Sysname.                      */
/*      09/27/18 - V2.06 - VNV - Change to get the Host+Domain and  */
/*                         then obtain the Hostid from there.       */
/********************************************************************/
/*                                                                  */

$vers                  = "v3.0"      /* Version number                */

parse source . . execName .

if SYSVAR("SYSENV") = "BACK" then do
   say exec_Name 'can only run online.'
   exit
   end
else do
   if SYSVAR(SYSISPF) <> "ACTIVE" then do       /* under READY mode */
      parse UPPER arg allParms
      queue "ISPSTART CMD("execName allParms") NEWAPPL(ISR)"
      exit
      end
   end

numeric digits 256

address ISPEXEC
mainPanel              = "$$CPUID$"
load_info = loadispf()

call Get_System_Data      /* goes thru MVS control blocks and
                            collects data                    */

dispRc = 0
do while dispRc = 0
   call Get_Dynamic_Data         /* update dynamic data      */
   "DISPLAY PANEL("mainPanel")"
   dispRc = rc
   end

do until length(load_info) = 0
   parse value load_info with dd libd load_info
   if LEFT(libd,6) = "ALTLIB" then do
      if libd = "ALTLIBC" then lib = "CLIST"
                          else lib = "EXEC"
      address TSO,
        "ALTLIB DEACT APPLICATION("lib")"
      end
   else "libdef" libd
   address TSO "FREE F("dd")"
   end

exit

/* ------------------------------------------------------------ *
 * Obtain z/OS data using either Control Block access or        *
 * MVSVAR function.  Also obtain values for all Static Symbols  *
 * i.e., &SYSRES, etc..  All values will be recorded in a       *
 * stem var.  For example, 'valueFor.SYSRES' will contain       *
 * the value for &SYSRES.  Other example: 'valueFor.SYSCLONE'   *
 * has the value for &SYSCLONE.  The & and ending '.' has been  *
 * removed so that theses variable names can be readily         *
 * available for use in Rexx.                                   *
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------ *
 * The following variables are available for Var substitution.  *
 * Remember that the JCL itself will not have variables         *
 * subtituted automatically.  The substitution is only done     *
 * on the 'Included' member (read the doc on how to use this).  *
 *                                                              *
 *     $csaSize - CSA size (in 'K')                             *
 *     $csaEsze - Extended CSA size (in 'K')                    *
 *     $ipladr  - IPL'ed Address                                *
 *     $ipladr$ - IPL'ed Address (after it has been TDMF'ed)    *
 *     $ipldt   - IPL'ed Date & Time                            *
 *     $iplvol  - IPL'ed Volser                                 *
 *     $jeslvl  - JES2 Level                                    *
 *     $jesnode - JES2 Nodename                                 *
 *     $load    - IPL Loadparm                                  *
 *     $load$   - IPL Loadparm (after it has been TDMF'ed)      *
 *     $lpar    - LPAR hardware name                            *
 *     $opsys   - Operating System Level                        *
 *     $ssmf    - SSMF version                                  *
 *     $sysid   - System Name                                   *
 *     $plex    - SYSPLEX name                                  *
 *     $pvtSize - Private Reg size (in 'K')                     *
 *     $pvtEsze - Extended Private Reg size (in 'K')            *
 *     $sqaSize - SQA size (in 'K')                             *
 *     $sqaEsze - Extended SQA size (in 'K')                    *
 *     smfid    - SMF id                                        *
 *                                                              *
 *     plus all static Symbolics, i.e. &SYSR0, &S1, &B1, etc.   *
 *                                                              *
 * ------------------------------------------------------------ */

Get_System_Data:
$opsys   = MVSVAR('SYSOPSYS')
$sysid   = MVSVAR('SYSNAME')
smfid    = MVSVAR('SYSSMFID')
$jeslvl  = SYSVAR('SYSJES')
$jesnode = SYSVAR('SYSNODE')

cvt      = Get_Stor('10'x)
ecvt     = Get_Stor(cvt,'8C'x)
asvt     = Get_Stor(cvt,'22C'x)
maxUser  = C2D(Get_Stor(asvt,'204'x))
ipa      = Get_Stor(ecvt,'188'x)
smca     = Get_Stor(cvt,'C4'x)
ucbadd   = Get_Stor(cvt,'30'x)
$iplvol  = Get_Stor(ucbadd,'1C'x,6)
$ipladr  = C2X(Get_Stor(ucbadd,4,2))
$iplprm  = Get_Stor(ecvt,'A0'x,8)
$cecnam  = Get_Stor(ecvt,'150'x,8)
$lparnam = Get_Stor(ecvt,'158'x,8)
cvtpre   = D2C(C2D(cvt)-40)
fmids    = Get_Stor(cvtpre,'8'x,8)
$ssmf    = Get_Stor(cvtpre,16,16)
$ssmfLvl = SUBSTR($ssmf,5,LENGTH($ssmf)-4)
$plex    = Get_Stor(ecvt,'8'x,8)
$load    = Get_Stor(ecvt,'A0'x,8)
$lpar    = Get_Stor(ecvt,344,8)
cvtixavl = Get_Stor(cvt,'7C'x)
iociovtp = Get_Stor(cvtixavl,'D0'x)
cssId    = C2X(Get_Stor(cvtixavl,'113'x,1))
cda      = Get_Stor(iociovtp,'18'x)
$shid    = Get_Stor(cvt,'42C'x,4)
$cpumdl  = Get_Stor($shid,'1A'x,6)"."Get_Stor($shid,'20'x,3)

/* --- Call IWMQVS  ------------------------------------------------- */

QVS_totL   = 512
QVS_len    = D2X(QVS_totL)
QVS_len    = RIGHT(X2C(QVS_len),4,D2C(0))
QVS_Out    = QVS_len||COPIES('00'X,QVS_totL-4)

address linkpgm 'IWMQVS QVS_Out'

If rc = 0 then do
   cec_type   = SUBSTR(QVS_Out,9,4)
   cec_model  = STRIP(SUBSTR(QVS_Out,13,16))
   select
      when cec_type = '2064' then cec_desc = '    z Series 900'
      when cec_type = '2066' then cec_desc = '    z Series 800'
      when cec_type = '2084' then cec_desc = '    z Series 990'
      when cec_type = '2086' then cec_desc = '    z Series 890'
      when cec_type = '2094' then cec_desc = '    System z9 EC'
      when cec_type = '2096' then cec_desc = '    System z9 BC'
      when cec_type = '2097' then cec_desc = '   System z10 EC'
      when cec_type = '2098' then cec_desc = '   System z10 BC'
      when cec_type = '2817' then cec_desc = ' zEnterprise 196'
      when cec_type = '2818' then cec_desc = ' zEnterprise 114'
      when cec_type = '2827' then cec_desc = 'zEnterprise EC12'
      when cec_type = '2828' then cec_desc = 'zEnterprise BC12'
      when cec_type = '2964' then cec_desc = '    z System z13'
      when cec_type = '2965' then cec_desc = '   z System z13s'
      when cec_type = '3906' then cec_desc = '    z System z14'
      otherwise                   cec_desc = ' Unkwn CPU model'
      end
   if SUBSTR($cpumdl,8,3) <> cec_model then do
      $cpumdl = $cpumdl"("cec_model")"
      end
   end

$cecDesc = CENTER(" ("STRIP(cec_desc)") ",56,'.')
$hwname  = STRIP(Get_Stor(ipa,'18'x,8))
iodfDsn  = STRIP(Get_Stor(cda,'20'x,44))
iodfDate = STRIP(Get_Stor(cda,156,8))
iodfTime = STRIP(Get_Stor(cda,164,8))
catDsn   = STRIP(Get_Stor(ipa,'EA'x,44))
catVol   = STRIP(Get_Stor(ipa,'E0'x,6))

rmct     = Get_Stor(cvt,604)
iralcct  = Get_Stor(rmct,620)
cct      = Get_Stor(rmct,4)
rct      = Get_Stor(rmct,'E4'x)

svcUnt   = C2D(Get_Stor(rmct,64))
suSec    = STRIP(FORMAT((16000000/svcUnt),8,2))

iplti    = C2D(Get_Stor(smca,'150'x))%360000
ipltrm   = C2D(Get_Stor(smca,'150'x))//360000
ipltd    = RIGHT(ipltrm%6000,2,'0')               /* # of minutes */

iplt     = iplti||'.'||ipltd
ipld     = C2X(Get_Stor(smca,'154'x))

iplyear  = "20"||SUBSTR(ipld,3,2)||SUBSTR(ipld,5,3)
$dayago  = $DATE("J2R","20"||date('J'))-$DATE("J2R",iplyear)
$saveAgo = $dayago
$i       = $DATE("J2G",iplyear)

select
   when $dayago = 0 then $dayago = "(IPLed today)"
   when $dayago = 1 then $dayago = "(Yesterday)"
   otherwise             $dayago = "("$dayago" days ago)"
   end

$ipldt   = SUBSTR($i,1,6)||SUBSTR($i,9,2) "-" iplt
drop iplti ipltrm ipltd iplt ipld iplyear $i

csd      = Get_Stor(cvt,'294'x)
rcvt     = Get_Stor(cvt,'3E0'x)
pccavt   = Get_Stor(cvt,'2FC'x)

gda      = Get_Stor(cvt,'230'x)
gdpsIni  = Get_Stor(iociovtp,'10B'x,1)
gdpsAct  = C2D(Get_Stor(iociovtp,'170'x,1))

if gdpsIni = '00'x then do      /* not config with alternate schset */
   gdpsAct = " "
   gdpsIni = " "                /* No channel set used */
   end

if gdpsAct > 1 then do
   gdpsAct = " "     /* APAR OA32339 not applied */
   end

getInit    = SOCKET('INITIALIZE','TCPINFO',1)
parse var getInit INIT_RC getSubTaskid getMaxDesc getService
if INIT_RC = 1004 then do
   tsab    = Get_Stor(ecvt,176)
   tsablen = C2D(Get_Stor(tsab,4,2))
   tsebnum = (tsablen-64)/128
   do i=1 to tsebnum
      tseb    = D2C(C2D(tsab)+64+(i-1)*128)
      if Get_Stor(tseb) <> "TSEB" then leave
      tcpasid = Get_Stor(tseb,56,2)
      if C2X(tcpasid) <> 0 then do
         stcName = Get_Stor(tseb,16,8)
         getInit = SOCKET('INITIALIZE','TCPINFO',1,stcName)
         parse var getInit INIT_RC getSubTaskid getMaxDesc getService
         if INIT_RC = 0 then leave
         end
      end
   end

if INIT_RC =  0 then do
   getHostid = SOCKET('GETHOSTID')
   getHostNm = SOCKET('GETHOSTNAME')
   getDomain = SOCKET('GETDOMAINNAME')
   parse var getHostid tcpRc tcpAddr    /* this is the main IP */
   parse var getHostNm tcpRc tcpName
   parse var getDomain tcpRc tcpDomain
   $fullDns  = STRIP(tcpName'.'tcpDomain)
   getNewIP  = SOCKET('GETHOSTBYNAME',$fullDns)
   parse var getNewIP  tcpRc $pingAdd
   if WORD($pingAdd,1) = "EHOSTNOTFOUND" then $pingAdd = tcpAddr
   getTerm   = SOCKET('TERMINATE')
   end
else do
   $fullDns = ""
   $pingAdd = ""
   end


OnLinstg = STRIP(FormatNumber(C2D(Get_Stor(cvt,'358'x))/1024)||'M')

secDsn   = Get_Stor(rcvt,56,44)
secType  = Get_Stor(rcvt,,4)

select
   when secType = 'RCVT' then secSoft = 'RACF'
   when secType = 'RTSS' then secSoft = 'TopSecret'
   otherwise secSoft = sectype
   end

onlCp   = C2D(Get_Stor(csd,212,4))

totalCp = 0
zaapCp  = 0
ziipCp  = 0
nextCp  = D2C(C2D(pccavt)-4)

do i=1 to 16
   t = "$sn"||RIGHT(i,2,'0')
   t = t "= ''"
   interpret t
   end

actCnt = 1

do until totalcp = onlCp
   nextCp = D2C(C2D(nextCp)+4)
   pcca   = Get_Stor(nextCp)
   if C2D(pcca) = 0 then iterate
   pccaSer  = Get_Stor(pcca,4,12)
   pccaVer  = Get_Stor(pcca,4,2)
   pccaId   = RIGHT(C2D(Get_Stor(pcca,16,2)),2,'0')
   pccaType = C2X(Get_Stor(pcca,'C'x))
   pccaAttr = Get_Stor(pcca,376,1)
   sn = pccaId"-"SUBSTR(pccaSer,3,6)
   if BITAND(pccaAttr,'01'x) = '01'x then do
      zaapCp = zaapCp + 1
      sn = sn||"_zAAp"
      end
   if BITAND(pccaAttr,'04'x) = '04'x then do
      ziipCp = ziipCp + 1
      sn = sn||"_zIIp"
      end
   tempCnt = RIGHT(actCnt,2,'0')
   t = "$sn"||tempCnt
   t = t "=" "'"sn"'"
   interpret t
   actCnt  = actCnt  + 1
   totalCp = totalCp + 1
   end

symTable  = Get_Stor(ecvt,'128'x)
numSym    = C2D(Get_Stor(symTable,2,2))
symAddr   = D2C(C2D(symTable)+4)
valueFor. = ''
do i=1 to numSym
   t = (i-1)*16
   nextSym  = D2C(C2D(symAddr)+t)
   s_off    = C2D(Get_Stor(nextSym,0,4))
   s_leng   = C2D(Get_Stor(nextSym,4,4))
   v_off    = C2D(Get_Stor(nextSym,8,4))
   v_leng   = C2D(Get_Stor(nextSym,12,4))
   mySym    = STRIP(Get_Stor(symAddr,s_off,s_leng))
   mySym    = STRIP(STRIP(mySym,'L','&'),'T','.')
   if v_leng > 0 then do
      valueFor.mySym = Get_Stor(symAddr,v_off,v_leng)
      end
   else do
      valueFor.mySym = ''
      end
   t = mySym||"='"valueFor.mySym"'"
   interpret t
   if mySym ¬= "" then do
      address ISPEXEC "VPUT ("mySym") SHARED"
      end
   end

/* ------------------------------------------------------------ *
 * Check the LOAD addr and LOADPARM to see if these UCBs have   *
 * been TDMF'ed.  If so, the new UCB will be reflected in the   *
 * two new vars: $ipladr$ and $load$ (the original vars were    *
 * $ipladr and $load, respectively).                            *
 * ------------------------------------------------------------ */

$ipladr$ = $ipladr               /*  First set the $vars$ to be */
$load$   = $load                 /*  the same as the original   */

/* ------------------------------------------------------------ *
 * First check the $iplvol (it was derived from the recorded    *
 * IPL'ed UCB.  If it is not same as SYSR1, then the IPL vol    *
 * has been TDMF'ed.  Need to get the new UCB, and also set     *
 * $iplvol to SYSR1.                                            *
 * ------------------------------------------------------------ */

if $iplvol ¬= sysr1 then do      /*  $iplvol came from ucb addr */
   $iplvol  = sysr1              /*  and it is different - TDMF */
   x = outtrap("trap.","*")
   address TSO "DVOL" $iplvol
   x = outtrap("off")
   do m=1 to trap.0
      parse var trap.m p_var1 p_var2 .
      if p_var1 = $iplvol then $ipladr$ = STRIP(p_var2)
      end
   end

/* ------------------------------------------------------------ *
 * Now check the IODF dsname.  Get the UCB for its volume and   *
 * if the first 4 char of loadparm is not the same, i.e. the    *
 * IODF volume has been TDMF'ed, then fix the loadparm to       *
 * reflect the new UCB (again new value stored in $load$).      *
 * ------------------------------------------------------------ */

t_iodfDsn = "'"iodfDsn"'"
x = LISTDSI(t_iodfDsn 'DIRECTORY NORECALL')
if x=0 | x=4  then do
   x = outtrap("trap.","*")
   address TSO "DVOL" sysvolume
   x = outtrap("off")
   do m=1 to trap.0
      parse var trap.m p_var1 p_var2 .
      if p_var1 = sysvolume then do
         $load$ = STRIP(RIGHT(p_var2,4,'0')||SUBSTR($load,5,4))
         end
      end
   end

/* ------------------------------------------------------------ *
 * This section of code just does a DVOL for M%xxxx to collect  *
 * the UCBs for all Mx volumes for the active res.  If DVOL     *
 * command is not available then the whole line is just set     *
 * to blank                                                     *
 * ------------------------------------------------------------ */

trap.0 = ""

x = Call_Dvol("VIMVS")

volCount = trap.0

/* -------------------------------------------------- *
 * Now sort VOL data                                  *
 * -------------------------------------------------- */


if trap.2 = trap.2 then trap.2 = ""
if trap.3 = trap.3 then trap.3 = ""
if trap.4 = trap.4 then trap.4 = ""
if trap.5 = trap.5 then trap.5 = ""
if trap.6 = trap.6 then trap.6 = ""

allDone = 0
do until allDone = 1
   allDone = 1
   do i=1 to volCount-1
      j=i+1
      if trap.i > trap.j then do

         tempData   = trap.J
         trap.J     = trap.I
         trap.I     = tempData

         allDone  = 0
         end                  /* if trap.i     */
      end                     /* do i=1      */
   end                        /* do until    */
/* ------------------------------------------------------ *
 * SORT ends                                              *
 * ------------------------------------------------------ */

j = 0

do i=1 to volCount
  fndVol    = LEFT(WORD(trap.i,1),6)
  fndAddr   = LEFT(WORD(trap.i,2),4)
  j = j + 1
  trap.j    = fndVol||"-"||fndAddr
  end

allVols = trap.1 "" trap.2 "" trap.3 "" trap.4 "" trap.5 "" trap.6

return 0


/* ------------------------------------------------------------ *
 * Issue DVOL command and trap output                           *
 * ------------------------------------------------------------ */

Call_Dvol:
arg Cvol .
address ispexec
x = outtrap("trap.","*")
"SELECT CMD(DVOL" Cvol" NOHEAD) NEWAPPL(ISR) PASSLIB NEST"
x = outtrap("off")
return 0


Get_Dynamic_Data:


csaSize  = Get_Stor(gda,'70'x)
csaEsze  = Get_Stor(gda,'80'x)
sqaSize  = Get_Stor(gda,'94'x)
sqaEsze  = Get_Stor(gda,'9C'x)
prvSize  = Get_Stor(gda,'A4'x)
prvEsze  = Get_Stor(gda,'AC'x)

$csaSize = FormatNumber(C2D(csaSize)/1024)
$csaEsze = FormatNumber(C2D(csaEsze)/1024)
$sqaSize = FormatNumber(C2D(sqaSize)/1024)
$sqaEsze = FormatNumber(C2D(sqaEsze)/1024)
$pvtSize = FormatNumber(C2D(prvSize)/1024)
$pvtEsze = FormatNumber(C2D(prvEsze)/1024)

realCpu  = C2D(Get_Stor(cct,102,2))
cputil   = realCpu||'%'

dots#    = 26                  /* length of the CPU Bar field */
tmpLeng  = realCpu%(100/26)    /* represent BUSY dots         */
cpubar   = CENTER(cputil,tmpLeng,'-')

if realCpu < 85  then do
   cpubar  = LEFT(cpubar,tmpLeng)||COPIES('-',dots#-tmpLeng)
   cpumask = COPIES('56'x,tmpLeng)||COPIES('55'x,dots#-tmpLeng)
   end
else if realCpu < 98  then do
   cpubar  = LEFT(cpubar,tmpLeng)||COPIES('-',dots#-tmpLeng)
   cpumask = COPIES('57'x,tmpLeng)||COPIES('55'x,dots#-tmpLeng)
   end
else do
   tmpLeng = (realCpu-100)%3.33
   cpubar  = LEFT(cpubar,dots#)||COPIES('-',tmpLeng)
   cpumask = COPIES('58'x,dots#)||COPIES('55'x,tmpLeng)
   end

avgCpu   = FORMAT(C2D(Get_Stor(rct,'38'x,2))/16,3,0)||"%"

tsoCnt   = 0
stcCnt   = 0
batCnt   = 0

asvt     = Get_Stor(cvt,'22C'x)
maxUser  = C2D(Get_Stor(asvt,'204'x))
offSet   = 0+C2D('20C'x)            /* first ASCB entry  */

do maxUser
   ascb    = Get_Stor(asvt,offSet)
   offSet  = offSet+4
   if BITAND(SUBSTR(ASCB,1,1),'80'x) = '80'x then iterate
   if C2D(ascb) = 0 then iterate
   if Get_Stor(ascb,0,4) ¬= "ASCB" then iterate

   jobni = Get_Stor(ASCB,172)
   jobns = Get_Stor(ASCB,176)

/*say Get_Stor(jobns,,8) Get_Stor(jobni,,8)  C2D(Get_Stor(ascb,'3C'x))*/

   if C2D(jobni) = 0 & C2D(jobns) = 0 then iterate

   if C2D(jobni) <> 0 then do
      batCnt = batCnt + 1
      end
   else do
      if C2D(Get_Stor(ascb,'3C'x)) = 0 then do
         if Get_Stor(jobns,,8) = "INIT" then nop
         else do
            stcCnt = stcCnt + 1
            end
         end
      else do
         tsoCnt = tsoCnt + 1
         end
      end
   end

return 0

/* ------------------------------------------------------------ *
 * This procedure format a number with ','.                     *
 * ------------------------------------------------------------ */

FormatNumber: procedure
   parse value arg(1) with whole "." decs

   formattedNumber = STRIP(REVERSE(TRANSLATE( "abc,def,ghi,jkl,mno",,
                                   REVERSE(whole),,
                                   "abcdefghijklmno",",")),"L",",")

  if decs <> "" then
     formattedNumber = formattedNumber || "." || decs
return formattedNumber


/*------------------------------------------------------------------*/
/*                                                                  */
/*      This procedure will extract data using the MVS Storage      */
/*      function. Input arguments will be:                          */
/*                                                                  */
/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */
/*         16 (like '10'x)                                          */
/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */
/*         D2C(256)                                                 */
/*      3) length of returned data in decimal, i.e. 256             */
/*                                                                  */
/*      NOTE - To make sure that this procedure will work all the   */
/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */
/*      of the calling REXX exec.                                   */
/*                                                                  */
/*------------------------------------------------------------------*/

Get_Stor: procedure

parse arg area,offset,leng

if ARG(2,'O') then offset=0

if ARG(3,'O') then leng=4

if DATATYPE(area) = 'CHAR' then do
   area =  C2D(area)
   End

if DATATYPE(offset) = 'CHAR' then do
   offset =  C2D(offset)
   End

return  STORAGE((D2X(area+offset)),leng)


/*------------------------------------------------------------------*/
/*                                                                  */
/*      This REXX exec will do date conversion:                     */
/*                                                                  */
/*      call Format:  DATE = $DATE(CODE,INPUT)                      */
/*                                                                  */
/*          CODE = 'J2G' - Julian to Gregorian date                 */
/*          CODE = 'G2J' - Gregorian date to Julian                 */
/*          CODE = 'J2R' - Julian to Relative date                  */
/*          CODE = 'R2J' - Relative to Julian date                  */
/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */
/*                                                                  */
/*          INPUT = either 'mm/dd/YYYY' or 'YYYYDDD' or 'nnnn'      */
/*                                                                  */
/*      Errors during processing will return 0 as result and        */
/*      an error message will be displayed as well.                 */
/*                                                                  */
/*------------------------------------------------------------------*/

$DATE: procedure

parse Upper arg func,date

if date = '' then retDate = 0
else select
      when func = 'J2G' then retDate = J2G_PROC(date)
      when func = 'G2J' then retDate = G2J_PROC(date)
      when func = 'J2R' then retDate = J2R_PROC(date)
      when func = 'R2J' then retDate = R2J_PROC(date)
      when func = 'R2D' then retDate = R2D_PROC(date)
      otherwise do
         say 'DT999E - Invalid function code as' func
         retDate = 0
         end
   end

return retDate



J2G_PROC: procedure

parse arg julDate

call VALIDATE_JULIAN
if RESULT = 0 then gDate = 0
else do
   julianYYYY  = SUBSTR(julDate,1,4)
   julianDDD   = SUBSTR(julDate,5,3)
   mo.1  = 31
   mo.2  = 28
   mo.3  = 31
   mo.4  = 30
   mo.5  = 31
   mo.6  = 30
   mo.7  = 31
   mo.8  = 31
   mo.9  = 30
   mo.10 = 31
   mo.11 = 30
   mo.12 = 31
   if LEAP_YEAR(julianYYYY) then mo.2 = 29
   do I=1 to 12 while julianDDD > mo.I
      julianDDD = julianDDD - mo.I
      end
   mm   = RIGHT(I,2,'0')
   dd   = RIGHT(julianDDD,2,'0')
   gDate = mm||'/'||dd||'/'||julianYYYY
   end

return gDate


G2J_PROC: procedure

parse arg gregDate
parse var gregDate mm '/' dd '/' YYYY
J_DATE = 0

if DATATYPE(mm)   ¬= 'NUM' | ,
   DATATYPE(dd)   ¬= 'NUM' | ,
   DATATYPE(YYYY) ¬= 'NUM' | ,
   dd > 31                 | ,
   mm < 1                  | ,
   mm > 12                 | ,
   YYYY > 9999          then ,
      say 'DT001E - Invalid Gregorian date as' gregDate
else do
   mo.1  = 31
   mo.2  = 28
   mo.3  = 31
   mo.4  = 30
   mo.5  = 31
   mo.6  = 30
   mo.7  = 31
   mo.8  = 31
   mo.9  = 30
   mo.10 = 31
   mo.11 = 30
   mo.12 = 31
   if LEAP_YEAR(YYYY) then mo.2 = 29
   mm = STRIP(mm,'L','0')
   if (dd > VALUE(mo.mm)) then ,
       say 'DT002E - Out-of-range date as' gregDate
   else do
      jAccumDay = 0
      if mm > 1 then do I=1 to (mm-1)
         jAccumDay = jAccumDay + mo.I
         end
      jAccumDay = jAccumDay + dd
      J_DATE      = YYYY||RIGHT(jAccumDay,3,'0')
      end
   end

return J_DATE




J2R_PROC: procedure

parse arg julDate

call VALIDATE_JULIAN
if RESULT = 1 then relDate = ((julianYYYY-1) * 365) + ,
                            ((julianYYYY-1) % 4) - ,
                            ((julianYYYY-1) % 100) + ,
                            ((julianYYYY-1) % 400) + (julianDDD)
   else relDate = 0
return relDate



R2J_PROC: procedure
parse arg REL_DATE
RETURNED_J = 0

if DATATYPE(REL_DATE) ¬= 'NUM' then ,
   say 'DT006E - Relative date non-numeric as' REL_DATE
else do
   if REL_DATE > 3652424 then ,
      say 'DT007E - Relative date out-of-range as' REL_DATE
   else do
      temp_YYYY = (REL_DATE % 366) + 1
      temp_REL = J2R_PROC(RIGHT(temp_YYYY,4,'0')||'000')
      do while (REL_DATE - temp_REL) > 0
         if LEAP_YEAR(temp_YYYY) then LEFT_OVER = 366
         else LEFT_OVER = 365
         if LEFT_OVER < (REL_DATE - temp_REL) then do
            temp_REL  = temp_REL  + LEFT_OVER
            temp_YYYY = temp_YYYY + 1
            end
         else do
            temp_DDD = (REL_DATE - temp_REL)
            leave
            end
         end
      RETURNED_J =  RIGHT(temp_YYYY,4,'0')||RIGHT(temp_DDD,3,'0')
   end
end

return RETURNED_J


R2D_PROC: procedure
parse arg REL_DATE
RETURNED_DAY = 0
if DATATYPE(REL_DATE) ¬= 'NUM' then ,
   say 'DT006E - Relative date non-numeric as' REL_DATE
else do
   if REL_DATE > 3652424 then ,
      say 'DT007E - Relative date out-of-range as' REL_DATE
   else do
      DAY_INDEX = (REL_DATE // 7)+1
      RETURNED_DAY  = WORD('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)
   end
end

return RETURNED_DAY





VALIDATE_JULIAN:

VALID_DATE = 0

if LENGTH(julDate) ¬=7 | DATATYPE(julDate) ¬= 'NUM' then
   say 'DT003E - Date too short/long or non-numeric as' julDate
else do
   julianYYYY = SUBSTR(julDate,1,4)
   julianDDD   = SUBSTR(julDate,5,3)
   if (julianDDD > 366) then ,
      say 'DT004E - Number of day > 366 as' julianDDD
   else if (LEAP_YEAR(julianYYYY) = 0) & (julianDDD = 366) then ,
          say 'DT005E - Invalid days for a non-leap year as' julianYYYY
        else if (julianYYYY < 1) then ,
           say 'DT008E - Invalid year as' julianYYYY
           else VALID_DATE = 1
   end
return VALID_DATE



LEAP_YEAR: procedure
parse arg YEAR_CHECKED

if (YEAR_CHECKED // 100) = 0 then ,
   if (YEAR_CHECKED // 400) = 0 then LEAP_YEAR_FLAG = 1
   else LEAP_YEAR_FLAG = 0
else if (YEAR_CHECKED // 4) = 0 then LEAP_YEAR_FLAG = 1
   else LEAP_YEAR_FLAG = 0

return LEAP_YEAR_FLAG




/* --------------------  rexx procedure  -------------------- *
 * Name:      LoadISPF                                        *
 *                                                            *
 * Function:  Load ISPF elements that are inline in the       *
 *            REXX source code.                               *
 *                                                            *
 * Syntax:    rc = loadispf()                                 *
 *                                                            *
 *            The inline ISPF resources are limited to        *
 *            ISPF Messages, Panels, and Skeletons,           *
 *                 CLISTs and EXECs are also supported.       *
 *                                                            *
 *            The inline resources must start in column 1     *
 *            and use the following syntax:                   *
 *                                                            *
 *            >START    used to indicate the start of the     *
 *                      inline data                           *
 *                                                            *
 *            >END    - used to indicate the end of the       *
 *                      inline data                           *
 *                                                            *
 *            Each resource begins with a type record:        *
 *            >type name                                      *
 *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
 *                     name is the name of the element        *
 * ---------------------------------------------------------- */
 LoadISPF: procedure

 parse value "" with null kmsg kpanel kskel first returns ,
                     kclist kexec
/* ------------------------------------------------------- *
 * Find the InLine ISPF Elements and load them into a stem *
 * variable.                                               *
 *                                                         *
 * Elements keyword syntax:                                *
 * /*>START - start of inline data                         *
 * >CLIST name                                             *
 * >EXEC name                                              *
 * >MSG name                                               *
 * >PANEL name                                             *
 * >SKEL name                                              *
 * >END*/   - end of all inline data (optional if last)    *
 * ------------------------------------------------------- */
 last_line = SOURCELINE()
 do i = last_line to 1 by -1
    line = SOURCELINE(i)
    if TRANSLATE(LEFT(line,9)) = "/*>START " then leave
    end
 rec = 0
/* --------------------------------------------------- *
 * Flag types of ISPF resources by testing each record *
 * then add each record to the data. stem variable.    *
 * --------------------------------------------------- */
 do j = i+1 to last_line
    line = SOURCELINE(j)
    if TRANSLATE(LEFT(line,7)) = ">END*/ " then leave
    if TRANSLATE(LEFT(line,7)) = ">CLIST " then kclist = 1
    if TRANSLATE(LEFT(line,6)) = ">EXEC "  then kexec  = 1
    if TRANSLATE(LEFT(line,5)) = ">MSG "   then kmsg   = 1
    if TRANSLATE(LEFT(line,7)) = ">PANEL " then kpanel = 1
    if TRANSLATE(LEFT(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
    end

/* ----------------------------------------------------- *
 * Now create the Library and Load the Member(s)         *
 * ----------------------------------------------------- */
 address ISPEXEC
/* ----------------------------- *
 * Assign dynamic random ddnames *
 * ----------------------------- */
 clistdd = "lc"random(999)"$##"
 execDD  = "le"random(999)"$##"
 msgDD   = "lm"random(999)"$##"
 panelDD = "lp"random(999)"$##"
 skelDD  = "ls"random(999)"$##"

/* ---------------------------------------- *
 *  LMINIT and LmOpen each resource library *
 * ---------------------------------------- */
 if kclist <> null then do
    call Alloc_DD clistDD
    "LMINIT DATAID(CLIST) DDNAME("clistDD")"
    "LMOPEN DATAID("clist") OPTION(OUTPUT)"
    returns = STRIP(returns clistDD ALTLIBC)
    end
 if kexec <> null then do
    call Alloc_DD execDD
    "LMINIT DATAID(EXEC) DDNAME("execDD")"
    "LMOPEN DATAID("exec") OPTION(OUTPUT)"
    returns = STRIP(returns execDD ALTLIBE)
    end
 if kmsg <> null then do
    call Alloc_DD msgDD
    "LMINIT DATAID(MSG) DDNAME("msgDD")"
    "LMOPEN DATAID("msg") OPTION(OUTPUT)"
    returns = STRIP(returns msgDD ISPMLIB)
    end
 if kpanel <> null then do
    call Alloc_DD panelDD
    "LMINIT DATAID(PANEL) DDNAME("panelDD")"
    "LMOPEN DATAID("panel") OPTION(OUTPUT)"
    returns = STRIP(returns panelDD ISPPLIB)
    end
 if kskel <> null then do
    call Alloc_DD skelDD
    "LMINIT DATAID(SKEL) DDNAME("skelDD")"
    "LMOPEN DATAID("skel") OPTION(OUTPUT)"
    returns = STRIP(returns skelDD ISPSLIB)
    end

/* ----------------------------------------------- *
 * Process all records in the data. stem variable. *
 * ----------------------------------------------- */
 do i = 1 to rec
    record = data.i
    recordu = TRANSLATE(record)
    if LEFT(recordu,5) = ">END " then leave
    if LEFT(recordu,7) = ">CLIST " then do
       if first = 1 then call add_it
       type = "Clist"
       first = 1
       parse value record with x name
       iterate
       end
    if LEFT(recordu,6) = ">EXEC " then do
       if first = 1 then call add_it
       type = "Exec"
       first = 1
       parse value record with x name
       iterate
       end
    if LEFT(recordu,5) = ">MSG " then do
       if first = 1 then call add_it
       type = "Msg"
       first = 1
       parse value record with x name
       iterate
       end
    if LEFT(recordu,7) = ">PANEL " then do
       if first = 1 then call add_it
       type = "Panel"
       first = 1
       parse value record with x name
       iterate
       end
    if LEFT(recordu,6) = ">SKEL " then do
       if first = 1 then call add_it
       type = "Skel"
       first = 1
       parse value record with x name
       iterate
       end
   /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
           "LMPUT DATAID("clist") MODE(INVAR)" ,
                 "DATALOC(RECORD) DATALEN(80)"
      When type = "Exec" then
           "LMPUT DATAID("exec") MODE(INVAR)" ,
                 "DATALOC(RECORD) DATALEN(80)"
      When type = "Msg" then
           "LMPUT DATAID("msg") MODE(INVAR)" ,
                 "DATALOC(RECORD) DATALEN(80)"
      When type = "Panel" then
           "LMPUT DATAID("panel") MODE(INVAR)" ,
                 "DATALOC(RECORD) DATALEN(80)"
      When type = "Skel" then
           "LMPUT DATAID("skel") MODE(INVAR)" ,
                 "DATALOC(RECORD) DATALEN(80)"
      end
    end
 if type <> null then call add_it
/* ---------------------------------------------------- *
 * Processing completed - now lmfree the allocation and *
 * Libdef the library.                                  *
 * ---------------------------------------------------- */
 if kclist <> null then do
    Address TSO,
    "ALTLIB ACT APPLICATION(CLIST) FILE("clistDD")"
    "LMFREE DATAID("clist")"
    end
 if kexec <> null then do
    Address TSO,
    "ALTLIB ACT APPLICATION(EXEC) FILE("execDD")"
    "LMFREE DATAID("exec")"
    end
 if kmsg <> null then do
    "LMFREE DATAID("msg")"
    "LIBDEF ISPMLIB LIBRARY ID("msgDD") STACK"
    end
 if kpanel <> null then do
    "LIBDEF ISPPLIB LIBRARY ID("panelDD") STACK"
    "LMFREE DATAID("panel")"
    end
 if kskel <> null then do
    "LIBDEF ISPSLIB LIBRARY ID("skelDD") STACK"
    "LMFREE DATAID("skel")"
    end
 return returns

/* --------------------------- *
 * Add the Member using LmmAdd *
 * based upon type of resource *
 * --------------------------- */
 Add_It:
 if type = "Clist" then
    "LMMADD DATAID("clist") MEMBER("name")"
 if type = "Exec" then
    "LMMADD DATAID("exec") MEMBER("name")"
 if type = "Msg" then
    "LMMADD DATAID("msg") MEMBER("name")"
 if type = "Panel" then
    "LMMADD DATAID("panel") MEMBER("name")"
 if type = "Skel" then
    "LMMADD DATAID("skel") MEMBER("name")"
 type = null
 return

/* ------------------------------ *
 * ALlocate the temp ispf library *
 * ------------------------------ */
 Alloc_DD:
 arg dd
 address TSO
 if pos(LEFT(dd,2),"lc le") > 0 then
 "ALLOC F("dd") UNIT(SYSALLDA) SPA(5,5) CYL DIR(10)",
    "RECFM(F B) LRECL(80) BLKSIZE(6160)"
 else
 "ALLOC F("dd") UNIT(SYSALLDA) SPA(5,5) CYL DIR(10)",
    "RECFM(F B) LRECL(80) BLKSIZE(23440)"
 return

/* -------------------------------------------------------------------- *
 * Beginning of ISPF members to be built dynamically                    *
 * -------------------------------------------------------------------- */

/*>START
>Panel $$CPUID$
)ATTR
 [ AREA(DYNAMIC)
 \ AREA(SCRL) EXTEND(OFF)
 % TYPE(TEXT)   CAPS(OFF)
 # TYPE(OUTPUT) CAPS(ON)   COLOR(RED)
 | TYPE(INPUT)  CAPS(OFF)   COLOR(RED) HILITE(USCORE)
 + TYPE(TEXT)   INTENS(LOW)   CAPS(OFF)  COLOR(WHITE) SKIP(ON)
 ~ TYPE(TEXT)   CAPS(OFF)  COLOR(BLUE) SKIP(ON)
 ] TYPE(OUTPUT)             CAPS(OFF)  COLOR(TURQ) HILITE(REVERSE)
 ¦ TYPE(OUTPUT) CAPS(OFF)  COLOR(BLUE) HILITE(REVERSE) JUST(RIGHT)
 ! TYPE(TEXT)   CAPS(OFF)  COLOR(YELLOW)
 @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ)
 } TYPE(TEXT)   JUST(LEFT)  CAPS(OFF)  COLOR(TURQ)
 ¢ TYPE(OUTPUT) JUST(RIGHT) CAPS(OFF)  COLOR(TURQ)
 ^ TYPE(OUTPUT) JUST(LEFT)  CAPS(OFF)  COLOR(RED)
 ¬ TYPE(TEXT)   CAPS(OFF)  COLOR(GREEN)
 " TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)
 { TYPE(OUTPUT) CAPS(OFF) JUST(RIGHT) COLOR(YELLOW)
55 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(WHITE)  HILITE(REVERSE)
56 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(GREEN)  HILITE(REVERSE)
57 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(YELLOW) HILITE(REVERSE)
58 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(RED)    HILITE(REVERSE)
)BODY EXPAND(``)
@ZDATESTD   %-`-`"SYSTEM Information%`-`@ZTIMEL     +
+Cmd input%===> |ZCMD                                     +Scroll%===>_ZSCROLLD+
\DSAREA                                                                        \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
\                                                                              \
+` `}Press"ENTER}to refresh CPU Util or"END}to exit+` `
)AREA DSAREA DEPTH(20)
+¬Sysname: ]z   +           ¬Sysplex: @$PLEX     ¬IPLvol: @Z     }/@Z       +
¬Eyecatch: @$SSMF           ¬JESnode: @$JESNODE¬LoadParm: @$LOAD         +
+  ¬OPsys: @$OPSYS                              ¬IPLtime: @$IPLDT              +
{$CECDESC                                                ¬@$dayago             +
+¬CECname: ^$cecnam   ¬LPARname: ^$lparnam¬       SMF Id: ^smfid               +
+¬TotalCP: ^totalCp    ¬Zip/Zap: ^z ¬/+^z +   ¬CPU model: ^$cpumdl             +
+¬   IODF: ^iodfDsn                             ¬Host IP: ^$pingadd            +
¬IODFDate: ^iodfDate¬-^iodfTime +                                              +
+¬SecType: @secSoft        ¬ Sec DSN: @secDsn                                  +
+¬MstrCat: @catdsn                            ¬Catlg Vol: @catvol+             +
¬ ^allVols                                                                     +
~`.`+Online Storage:{OnLinstg  ~`.`
+¬Private: {$pvtSize   +(K)¬  Priv/E: {$pvtEsze   +(K)    ¬Active CSS: @cssId  +
+¬    CSA: {$csaSize   +(K)¬   CSA/E: {$csaEsze   +(K)    ¬    Schset: @gdpsAct+
+¬    SQA: {$sqaSize   +(K)¬   SQA/E: {$sqaEsze   +(K)
+ Sym:¬JESSSN  ¬:^JESSSN  ¬ SVTSC   :^SVTSC   ¬UNIXVER :^UNIXVER ¬         +
+     ¬VENDOR  ¬:^VENDOR  ¬ VTAMLST :^VTAMLST ¬     ---- CPU Utilization~-----
~.....+Su/Sec {susec   ~.......+SRM Avg CPU ¦Z   ~  [CPUBAR,CPUMASK            [
¬ CPU S/N: @$sn01           @$sn02          +     ¬Bat:^Z   ¬Tso:^Z   ¬Stc:^Z  +
+          @$sn03           @$sn04          +                                  +
+          @$sn05           @$sn06          +                                  +
+          @$sn07           @$sn08          +                                  +
+          @$sn09           @$sn10          +                                  +
+          @$sn11           @$sn12          +                                  +
+          @$sn13           @$sn14          +                                  +
+          @$sn15           @$sn16          +                                  +
}
+`.`{$VERS
)INIT
   .ZVARS = '($SYSID $IPLVOL $IPLADR$ ZIIPCP ZAAPCP +
              AVGCPU BATCNT TSOCNT STCCNT)'
   .HELP  = $INF$H01
   &$DEL1ST = N
   IF  (&ZSCROLLD = '')
        &ZSCROLLD = 'CURSOR'
)REINIT
   &$SEL = ''
)PROC
   &SCRAMT = TRUNC (&ZSCROLLD,1)
   IF  (&SCRAMT   = C)
        &ZSCROLLD = 'CURSOR'
   IF  (&SCRAMT   = P)
        &ZSCROLLD = 'PAGE'
   IF  (&SCRAMT   = H)
        &ZSCROLLD = 'HALF'
)END
>Panel $INF$H01
)ATTR DEFAULT(%+!)
   ! TYPE(NEF) PAD(USER) CAPS(ON)
   " TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)
   + TYPE(NT)
   { TYPE(TEXT)   CAPS(OFF)                  COLOR(TURQ)
   } TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(TURQ)
   ¢ TYPE(OUTPUT) CAPS(OFF)                  COLOR(RED)
   ¬ TYPE(TEXT)   CAPS(OFF)                  COLOR(WHITE)
   | TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(WHITE)
   \ TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(RED)
   _ TYPE(TEXT)   CAPS(OFF)                  COLOR(YELLOW)
   # AREA(SCRL) EXTEND(ON)
)BODY
%Tutorial -----------------"SYSTEM Information Display%---------------- Tutorial
%Command ===>!ZCMD                                                             +
+
+       }NOTE - use PF10 and PF11 to page up and down (ISPF tutorial)+
+
#SAREA                                                                         #
#                                                                              #
#                                                                              #
#                                                                              #
#                                                                              #
#                                                                              #
#                                                                              #
#                                                                              #
+
)AREA SAREA
+   This is a general system information display. In addition to the static
 information, some data will get refreshed as you press Enter.  That includes
 CPU utilization as RMF sees it, along with the total number of Bat/TSU/STC
 address spaces at the time. CPU utilization is presented as ISPF dynamic data,
 using different color based on the percentage, of which,\RED+color denotes\98+
 percent-plus utilization, while"YELLOW+means"85+percent-plus, etc..

    The{SRM Avg CPU+is what RMF used internally, which, in the past, was used to
 influence the¬'old'+SRM algorithm in making¬'swapping'+decision. Even with WLM,
 I do believe that some of this data is still used as part of the internal
 adjustment for workloads.

    Some other interesting information includes: CPU model. Most of the time,
 a machine was dynamically upgraded after the initial Power-on Reset. The Base
 CPU model will become a different number, in which case, the model will be
 listed inside the parentheses. This model normally shows up as part of the
¬D M=CPU+command under¬CPC SI+information.  The Machine type is listed on a
 seperate line, i.e. z13 vs z14 or EC12, etc..

    The total number of CP includes all zIIP/zAAp engines, and the next field
 will display how many of these zIIp/zAAp engines were there. The serial
 numbers displayed in a scrollable area below will indicate which engine(s)
 being the special one(s).

    In addition, there is a line showing the Volser/UCBs for the active volumes
 res volumes (up to 6).

    A list of the most frequently referrenced symbolics is also listed.

    Everything else should be self-explanatory.

¬------------------------------- End Of Tutorial ------------------------------+

)END
>END*/
